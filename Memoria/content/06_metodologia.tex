\chapter{Metodología}

En este capítulo se detalla la metodología seguida para el desarrollo del proyecto. Se incluye una explicación detallada de los principios que han fundamentado el desarrollo, el listado de las etapas del proyecto, y la descripción del uso de un repositorio de Git para gestionar el proyecto.

\section{Principios de diseño}

\subsection{Calidad sobre objetivos}

En la ejecución de este proyecto, se ha adoptado una postura estratégica que privilegia la calidad y precisión en cada fase del desarrollo por encima del cumplimiento de todos los objetivos planteados inicialmente. Esta decisión se fundamenta en la conciencia de que el trabajo actual es una parte de un esfuerzo continuo, y por tanto, es imperativo establecer una base sólida y bien definida que facilite futuras continuaciones y expansiones, promoviendo la visión a largo plazo del proyecto.

El enfoque en la calidad se justifica por varios motivos clave:

\begin{itemize}
	\item \textbf{Sostenibilidad del proyecto:} Realizar las tareas con un enfoque riguroso y meticuloso asegura que el sistema resultante sea robusto y fiable. Un trabajo bien hecho evita la acumulación de deuda técnica, lo cual es esencial para la sostenibilidad a largo plazo del proyecto.
	
	\item \textbf{Facilidad de continuación:} Dejando una documentación clara se facilita significativamente el trabajo de futuros desarrolladores. Esto es especialmente crítico en proyectos extensos donde la continuidad del desarrollo depende de la facilidad con la que nuevos desarrolladores puedan entender y construir sobre el trabajo previo.
	
	\item \textbf{Reducción de riesgos:} Priorizar la calidad y la claridad en el trabajo reduce la probabilidad de errores y fallos que podrían surgir de soluciones apresuradas o mal implementadas. Este enfoque minimiza riesgos y garantiza que cualquier problema futuro pueda ser abordado de manera efectiva.
	
	\item \textbf{Fomento de buenas prácticas:} Al enfocarse en hacer las cosas bien desde el principio, se promueve una cultura de buenas prácticas de ingeniería y desarrollo.
	
\end{itemize}

A continuación, se detallan las decisiones específicas que se han tomado para garantizar que el trabajo realizado no solo cumpla con los objetivos inmediatos, sino que también sea de la más alta calidad y preparado para futuras expansiones:

\begin{itemize}
	\item \textbf{Documentación exhaustiva:} Se ha invertido tiempo en crear una documentación detallada y clara, tanto para el \textit{hardware} (esquemáticos con notas explicativas), como para el \textit{firmware} (documentación autogenerada a partir de comentarios muy detallados).
	
	\item \textbf{Revisión y validación minuciosa:} Cada etapa del desarrollo ha sido sometida a rigurosas revisiones y procesos de validación. Esto incluye pruebas unitarias exhaustivas, revisiones de código con personas externas al proyecto y pruebas de integración para asegurar que todos los componentes funcionen correctamente en conjunto.
	
	\item \textbf{Diseño modular:} El diseño de cada parte ha sido cuidadosamente modularizado para permitir una fácil modificación y expansión. Cada módulo ha sido diseñado para ser independiente y cohesivo, facilitando su mantenimiento y actualización sin afectar al resto del proyecto.
	
	\item \textbf{Código limpio y legible:} Se ha priorizado la legibilidad y claridad del código por encima de la optimización extrema. Esto no solo facilita el entendimiento y la modificación del código por parte de nuevos desarrolladores, sino que también reduce la probabilidad de errores y simplifica la depuración.
\end{itemize}

\subsection{KISS}
La filosofía KISS (\textit{Keep It Simple, Stupid!}) \cite{KISS} ha sido un principio fundamental que ha guiado el diseño, la implementación y la validación del inversor. La simplicidad se ha considerado como una ventaja clave en todos los aspectos del proyecto, desde la elección de componentes hasta el desarrollo del \textit{firmware}.

Las razones por la que se cree que es necesario simplificar tanto como sea posible son las siguientes:
\begin{itemize}
	\item \textbf{Facilidad de comprensión:} Un diseño simple es más fácil de entender, lo que facilita la colaboración, el aprendizaje y el futuro desarrollo.
	\item \textbf{Mayor fiabilidad:} Los sistemas simples suelen ser más fiables que los complejos, ya que tienen menos puntos de fallo.
	\item \textbf{Facilidad de desarrollo:} Complicar un sistema que ya de por sí es complicado aumenta mucho el tiempo que se debe invertir para diseñarlo y hacerlo funcionar.
\end{itemize}

El trabajo consta de muchas partes relacionadas entre sí y se debe facilitar esta interacción entre las diferentes etapas del proyecto. Las decisiones que se han tomado para seguir esta filosofía son los siguientes:

\begin{itemize}
	\item \textbf{Minimizar la complejidad del diseño:} Se ha buscado simplificar el diseño del \textit{hardware} y del \textit{firmware} evitando soluciones excesivamente complicadas. Se han priorizado diseños limpios y directos que cumplan con los requisitos del proyecto, mitigando posibles errores derivados de la complejidad.
	
	\item \textbf{Utilizar herramientas y técnicas conocidas:} Se ha optado por utilizar herramientas y técnicas ampliamente conocidas y documentadas, como por ejemplo, la estrategia de modulación SVPWM o la topología VSI.
	
	\item \textbf{Simplificar los procesos de validación:} Se han diseñado procedimientos de prueba simples, efectivos y reproducibles. Interesa que esta etapa sea ágil, y que durante las pruebas se pueda mantener el foco en los problemas relacionados estrictamente con lo que se está ensayando.
	
\end{itemize}


\section{Modelo en V}
El modelo en V es un enfoque de desarrollo y validación que organiza las etapas del proyecto en forma de una 'V' invertida, donde cada etapa de desarrollo tiene una contraparte de validación. Esto asegura que la validación se considere desde el principio del proyecto y que cada fase de desarrollo tenga su correspondiente prueba o verificación asociada.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance=2cm]
		
		% Nodes
		\node (requisitos) [block] {Requisitos del sistema};
		\node (diseno_sistema) [block, below of=requisitos, xshift=0.7cm, yshift=-0.5cm] {Diseño del sistema};
		\node (diseno_detallado) [block, below of=diseno_sistema, xshift=0.7cm, yshift=-0.5cm] {Diseño detallado};
		\node (implementacion) [block, below of=diseno_detallado, xshift=0.7cm, yshift=-0.5cm] {Implementación};
		\node (pruebas_unitarias) [block, right of=implementacion, xshift=5cm, yshift=0cm] {Pruebas unitarias};
		\node (pruebas_integracion) [block, above of=pruebas_unitarias, xshift=0.7cm, yshift=0.5cm] {Pruebas de integración};
		\node (pruebas_sistema) [block, above of=pruebas_integracion, xshift=0.7cm, yshift=0.5cm] {Pruebas de sistema};
		\node (pruebas_aceptacion) [block, above of=pruebas_sistema, xshift=0.7cm, yshift=0.5cm] {Pruebas de aceptación};
		
		% Arrows
		\draw [arrow] (requisitos) -- (diseno_sistema);
		\draw [arrow] (diseno_sistema) -- (diseno_detallado);
		\draw [arrow] (diseno_detallado) -- (implementacion);
		\draw [arrow] (implementacion) -- (pruebas_unitarias);
		\draw [arrow] (pruebas_unitarias) -- (pruebas_integracion);
		\draw [arrow] (pruebas_integracion) -- (pruebas_sistema);
		\draw [arrow] (pruebas_sistema) -- (pruebas_aceptacion);
		
		% Additional arrows for test design
		\draw [arrow] (requisitos.east) -- ++(3.5cm,0) |- node[anchor=south]{Plan de pruebas} (pruebas_aceptacion.west);
		\draw [arrow] (diseno_sistema.east) -- ++(3cm,0) |- node[anchor=south]{Plan de pruebas} (pruebas_sistema.west);
		\draw [arrow] (diseno_detallado.east) -- ++(2.5cm,0) |- node[anchor=south]{Plan de pruebas} (pruebas_integracion.west);
		\draw [arrow] (implementacion.east) -- ++(1.75cm,0) |- node[anchor=south]{Plan de pruebas} (pruebas_unitarias.west);
	\end{tikzpicture}
	\caption{Modelo en V para el desarrollo y validación de sistemas.}
\end{figure}

En el modelo en V, las etapas de diseño se encuentran en el lado izquierdo de la 'V', comenzando desde los requisitos del sistema hasta la implementación y codificación. Por otro lado, las etapas de validación se encuentran en el lado derecho de la 'V', comenzando desde las pruebas unitarias y de integración hasta las pruebas de sistema y aceptación.

El modelo en V proporciona una estructura clara y sistemática para el desarrollo y validación del convertidor, asegurando que cada etapa tenga su correspondiente prueba de validación y que los resultados sean coherentes con los objetivos del proyecto. Sin embargo, es necesario ser pragmático y eficaz con la validación, puesto que tiende a llevar más tiempo del necesario si se sigue una metodología de forma estricta. Por ello, a lo largo de todo el proceso de diseño y de verificación se ha tomado la libertad de usar el modelo en V para aquello para lo que es útil, y ser más ágil con aquellas partes que lo requieran.

A continuación se enumeran las etapas del proyecto, aplicando pragmáticamente el modelo en V a este trabajo en específico.
\begin{enumerate}
\item \textbf{Definición de requisitos}

La primera etapa del proyecto se centra en la definición de los requisitos del inversor trifásico y su control. Aquí se establecen los objetivos, las especificaciones técnicas y los criterios que guiarán todo el desarrollo. Además, se identifican las necesidades y expectativas del equipo de Formula Student, asegurando que el proyecto cumpla con sus requerimientos específicos. La duración de esta etapa es excepcionalmente larga, pues requiere de mucha familiaridad con el entorno de la Formula Student y conocimiento sobre las necesidades reales del equipo. Se ha realizado a lo largo de los años, observando los problemas asociados a un inversor comercial que un inversor personalizado podría solucionar.

\item \textbf{Modelo continuo y simulación del control}

La siguiente etapa es el diseño del modelo en continuo y el desarrollo del control en Simulink. Aquí, se crea un modelo matemático del inversor y del motor PMSM y se implementa el control vectorial (FOC). Este proceso implica una comprensión profunda de la teoría detrás de los motores eléctricos y el diseño del control. Se basará en la representación macroscópica de la energía (EMR) con el fin de ilustrar la aplicación final del motor. La duración estimada para esta fase es de aproximadamente 2 meses.

\item \textbf{Discretización del modelo y simulación de la conmutación}

Al acabar la etapa anterior, se trabaja en la discretización del modelo y la simulación de la conmutación de los interruptores de potencia en PLECS. Aquí se tiene en cuenta la naturaleza discreta de la electrónica de potencia y se simula el comportamiento del inversor en el dominio del tiempo discreto. Además, esta simulación incorpora también el modelo térmico, con lo que se pueden extraer las pérdidas del inversor. Esta fase dura alrededor de 2 semanas, pues gran parte del modelo continuo se puede reutilizar para el discreto, centrándose más en los aspectos de la conmutación y la implementación en un sistema discreto como es un microcontrolador.

\item \textbf{Diseño del \textit{hardware}}

Con el diseño del control y la simulación de la conmutación como base, se procede al diseño del \textit{hardware}. Esto implica seleccionar componentes, diseñar esquemáticos y PCBs y planificar su validación. La duración estimada para esta etapa es de 3 a 4 meses, y se solapa parcialmente con el diseño del \textit{firmware}.

\item \textbf{Diseño del \textit{firmware}}

Simultáneamente con el diseño del \textit{hardware}, se trabaja en el desarrollo del \textit{firmware}. Esto incluye programar el microcontrolador que controlará el inversor y la implementación del algoritmo de control. Se utilizará una placa de evaluación antes de tener la placa de control propia con tal de acelerar el desarrollo. La duración estimada para esta fase es de aproximadamente 4 meses y se puede solapar con otras etapas.

\item \textbf{Validación del \textit{hardware}}

Una vez que el \textit{hardware} se está construyendo, se procede a la validación con las pruebas planeadas anteriormente. La duración estimada para esta etapa es de aproximadamente 3 a 4 meses y se superpone con el desarrollo del \textit{firmware}.

\item \textbf{Validación del \textit{firmware}}

La validación del \textit{firmware} se realiza una vez que el \textit{hardware} está validado, y mayoritariamente, se puede realizar durante el mismo desarrollo del código. Aquí, se llevan a cabo pruebas unitarias para garantizar que cada módulo funcione según lo previsto y ver que las simulaciones y cálculos previos se ajusten a la realidad. La duración estimada para esta etapa es de 2 meses.

\item \textbf{Documentación y preparación para la implementación}

La fase final del proyecto se enfoca en la documentación y la preparación para su implementación en los monoplazas de e-Tech Racing. La duración estimada para esta etapa es de aproximadamente un par de semanas. 

\end{enumerate}

\newpage

\begin{landscape}
	\begin{figure}[H]
		\centering
		\begin{ganttchart}[
			hgrid,
			vgrid,
			y unit chart=0.7cm,
			x unit=1.5cm,
			time slot format=isodate-yearmonth,
			time slot unit=month,
			bar/.append style={fill=blue!30},
			bar label font=\footnotesize,
			group label font=\footnotesize,
    		newline shortcut=true,
			]{2023-09}{2024-06}
			\gantttitlecalendar{year, month=shortname} \\ % abreviar nombres de meses
			\ganttbar{Modelo continuo y simulación del control}{2023-09}{2023-10} \\
			\ganttbar{Discretización del modelo y simulación de la conmutación}{2023-10}{2023-11} \\
			\ganttbar{Diseño del \textit{hardware}}{2023-10}{2024-01} \\
			\ganttbar{Diseño del \textit{firmware}}{2024-01}{2024-06} \\
			\ganttbar{Validación del \textit{hardware}}{2024-02}{2024-05} \\
			\ganttbar{Validación del \textit{firmware}}{2024-05}{2024-06} \\
			\ganttbar{Documentación y preparación para la implementación}{2024-06}{2024-06} \\
			
			\ganttmilestone{Trabajo finalizado}{2024-06}
			\end{ganttchart}
			\caption{Diagrama de Gantt para el proyecto}	
	\end{figure}
\end{landscape}
	
\newpage

Es importante destacar que las etapas de diseño del \textit{hardware} y del \textit{firmware} pueden superponerse y solaparse con otras etapas, lo que permite un desarrollo más ágil y eficiente del proyecto. La superposición de estas etapas es esencial para cumplir con los plazos y garantizar que el proyecto avance de manera constante. El trabajo se ha realizado en el marco de un año académico, de septiembre a junio, aunque la definición de requisitos y los primeros pasos del modelo continuo se realizaron antes del comienzo del trabajo.

\section{Gestión del proyecto con Git}
\subsection{Introducción a Git}
Git es un sistema de control de versiones distribuido, diseñado para rastrear cambios en archivos y coordinar el trabajo entre múltiples personas en proyectos de desarrollo de \textit{software}. Utiliza un enfoque descentralizado, lo que significa que cada desarrollador tiene una copia completa del historial de cambios del proyecto. Git facilita el trabajo colaborativo, la gestión de cambios y la integración continua en proyectos de cualquier tamaño. Existen otros sistemas de control de versiones como SVN, pero Git es el más popular.

\subsection{Funcionamiento de Git}
Git trabaja mediante la creación de instantáneas (\textit{commits}) de los archivos en un repositorio. Cada vez que se realiza un cambio significativo en los archivos del proyecto, el desarrollador crea un nuevo \textit{commit} que contiene una instantánea del estado de esos archivos en ese momento. Estos \textit{commits} se organizan en ramas (\textit{branches}), que permiten trabajar en paralelo en diferentes partes sin afectarse mutuamente. Las ramas se fusionan (\textit{merge}) cuando el trabajo está completo y se quiere incorporar al código principal. En este proyecto solo se ha usado una rama puesto que solo hay un desarrollador.

\subsection{Por qué utilizar un sistema de control de versiones}
El uso de un sistema de control de versiones como Git proporciona numerosos beneficios para el desarrollo de proyectos de ingeniería \cite{GestionProyectos}, incluyendo:

\begin{itemize}
	\item \textbf{Historial de cambios:} Permite mantener un registro detallado de todas las modificaciones realizadas en el código y otros archivos del proyecto, lo que facilita la identificación de errores y el seguimiento del progreso del desarrollo.
	\item \textbf{Seguridad:} Proporciona una copia de seguridad del código en caso de pérdida o corrupción de los archivos locales.
	\item \textbf{Experimentación:} Permite probar nuevas ideas y características con la tranquilidad de que la versión anterior está guardada.
\end{itemize}

\subsection{Uso de Git en el proyecto}
En el desarrollo de este proyecto, Git se utilizó para gestionar no solo el \textit{firmware}, sino también las simulaciones, la documentación y el diseño del \textit{hardware}. Cada aspecto del proyecto se organizó en una carpeta del mismo repositorio de Git, lo que permitió un seguimiento preciso de los cambios.

\subsection{GitHub}
GitHub es una plataforma de alojamiento de código que utiliza Git como sistema de control de versiones. Ofrece funciones adicionales como seguimiento de problemas, gestión de proyectos y revisión de código. En este proyecto, se utilizó GitHub para alojar el repositorio de Git.

\subsection{Automatización de la documentación y \textit{releases}}
Una de las ventajas de utilizar Git y GitHub es la capacidad de automatizar tareas como la generación de documentación y la creación de \textit{releases}. En este proyecto, se generó automáticamente una \textit{wiki} utilizando los contenidos de esta memoria, lo cual facilitó la creación y el mantenimiento de documentación actualizada \cite{InverterWiki}.

Además, se realizaron \textit{releases} de \textit{hardware} mediante el etiquetado de versiones en Git. Cada vez que se solicitaban PCBs, se creaba una nueva \textit{release} que incluía los archivos de fabricación de las PCBs, una lista detallada de los cambios realizados desde la última versión, y se iban actualizando las \textit{release notes} con los errores que se iban encontrando.


